Rohit's working manipulator code (Base+ L1 + L2)



#include <Arduino.h>
#include <ESP32Encoder.h>

#include <micro_ros_platformio.h>
#include <rcl/rcl.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
#include <std_msgs/msg/float32.h>

#define MOTOR_PWM_BASE 16
#define MOTOR_DIR_BASE 4
#define ENCODER_BASE_A 33
#define ENCODER_BASE_B 32

#define MOTOR_PWM_L1 5
#define MOTOR_DIR_L1 17
#define ENCODER_L1_A 35
#define ENCODER_L1_B 34

#define MOTOR_PWM_L2 22
#define MOTOR_DIR_L2 21
#define ENCODER_L2_A 39
#define ENCODER_L2_B 36

#define CPR_BASE 120000.0
#define CPR_L1 37500.0
#define CPR_L2 120000.0

const int pwmFreq = 20000;
const int pwmRes = 8;
const int chBase = 0;
const int chL1 = 1;
const int chL2 = 2;

const int fixedPWM = 100;
const float angleTolerance = 2.0;

ESP32Encoder encBase;
ESP32Encoder encL1;
ESP32Encoder encL2;

float targetBase = 0;
float targetL1 = 0;
float targetL2 = 0;

bool activeBase = false;
bool activeL1 = false;
bool activeL2 = false;

rcl_node_t node;
rclc_executor_t executor;
rcl_allocator_t allocator;
rclc_support_t support;
rcl_timer_t timer;

rcl_subscription_t subBase, subL1, subL2;
rcl_publisher_t pubBase, pubL1, pubL2;

std_msgs__msg__Float32 msgBaseAngle, msgL1Angle, msgL2Angle;
std_msgs__msg__Float32 msgBaseTarget, msgL1Target, msgL2Target;

float getAngle(long count, float cpr) {
  return (count / cpr) * 360.0;
}

void motorDrive(int channel, int dirPin, int pwm) {
  bool dir = pwm >= 0;
  digitalWrite(dirPin, dir);
  ledcWrite(channel, abs(pwm));
}

bool updateMotor(ESP32Encoder &enc, int channel, int dirPin,
                 float target, float cpr, const char *name) {
  float angle = getAngle(enc.getCount(), cpr);
  float error = target - angle;
  bool done = fabs(error) <= angleTolerance;

  if (!done) {
    int pwm = (error > 0) ? fixedPWM : -fixedPWM;
    motorDrive(channel, dirPin, pwm);
  } else {
    motorDrive(channel, dirPin, 0);
  }

  return done;
}

// callbackss
void cbBaseTarget(const void *msgin) {
  const std_msgs__msg__Float32 *msg = (const std_msgs__msg__Float32 *)msgin;
  targetBase = msg->data;
  activeBase = true;
}

void cbL1Target(const void *msgin) {
  const std_msgs__msg__Float32 *msg = (const std_msgs__msg__Float32 *)msgin;
  targetL1 = msg->data;
  activeL1 = true;
}

void cbL2Target(const void *msgin) {
  const std_msgs__msg__Float32 *msg = (const std_msgs__msg__Float32 *)msgin;
  targetL2 = msg->data;
  activeL2 = true;
}

// timer callback
void timer_callback(rcl_timer_t *timer, int64_t last_call_time) {
  (void)last_call_time;
  msgBaseAngle.data = getAngle(encBase.getCount(), CPR_BASE);
  msgL1Angle.data = getAngle(encL1.getCount(), CPR_L1);
  msgL2Angle.data = getAngle(encL2.getCount(), CPR_L2);

  rcl_publish(&pubBase, &msgBaseAngle, NULL);
  rcl_publish(&pubL1, &msgL1Angle, NULL);
  rcl_publish(&pubL2, &msgL2Angle, NULL);
}

void setup() {
  Serial.begin(115200);
  delay(2000);

  ESP32Encoder::useInternalWeakPullResistors = puType::up;
  encBase.attachHalfQuad(ENCODER_BASE_A, ENCODER_BASE_B);
  encL1.attachHalfQuad(ENCODER_L1_A, ENCODER_L1_B);
  encL2.attachHalfQuad(ENCODER_L2_A, ENCODER_L2_B);
  encBase.clearCount();
  encL1.clearCount();
  encL2.clearCount();

  pinMode(MOTOR_DIR_BASE, OUTPUT);
  pinMode(MOTOR_DIR_L1, OUTPUT);
  pinMode(MOTOR_DIR_L2, OUTPUT);

  ledcSetup(chBase, pwmFreq, pwmRes);
  ledcSetup(chL1, pwmFreq, pwmRes);
  ledcSetup(chL2, pwmFreq, pwmRes);
  ledcAttachPin(MOTOR_PWM_BASE, chBase);
  ledcAttachPin(MOTOR_PWM_L1, chL1);
  ledcAttachPin(MOTOR_PWM_L2, chL2);

  set_microros_transports();
  allocator = rcl_get_default_allocator();
  rclc_support_init(&support, 0, NULL, &allocator);
  rclc_node_init_default(&node, "manip_3link", "", &support);

  // Publishers
  rclc_publisher_init_default(&pubBase, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "base/angle");
  rclc_publisher_init_default(&pubL1, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "l1/angle");
  rclc_publisher_init_default(&pubL2, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "l2/angle");

  // Subscribers
  rclc_subscription_init_default(&subBase, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "base/target");
  rclc_subscription_init_default(&subL1, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "l1/target");
  rclc_subscription_init_default(&subL2, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "l2/target");

  // Timer
  rclc_timer_init_default(&timer, &support, RCL_MS_TO_NS(100), timer_callback);

  
  rclc_executor_init(&executor, &support.context, 4, &allocator);
  rclc_executor_add_timer(&executor, &timer);
  rclc_executor_add_subscription(&executor, &subBase, &msgBaseTarget, &cbBaseTarget, ON_NEW_DATA);
  rclc_executor_add_subscription(&executor, &subL1, &msgL1Target, &cbL1Target, ON_NEW_DATA);
  rclc_executor_add_subscription(&executor, &subL2, &msgL2Target, &cbL2Target, ON_NEW_DATA);
}

void loop() {
  
  rclc_executor_spin_some(&executor, RCL_MS_TO_NS(10));

  if (activeBase && updateMotor(encBase, chBase, MOTOR_DIR_BASE, targetBase, CPR_BASE, "Base"))
    activeBase = false;

  if (activeL1 && updateMotor(encL1, chL1, MOTOR_DIR_L1, targetL1, CPR_L1, "L1"))
    activeL1 = false;

  if (activeL2 && updateMotor(encL2, chL2, MOTOR_DIR_L2, targetL2, CPR_L2, "L2"))
    activeL2 = false;

  delay(10);
}
