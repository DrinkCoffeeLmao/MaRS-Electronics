//---------------updated science and sensor final-----------------------





#include <Arduino.h>

#include <micro_ros_platformio.h>
#include <rcl/rcl.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>

#include <std_msgs/msg/int16.h>
#include <std_msgs/msg/string.h>
#include <std_msgs/msg/float32.h>

#include <math.h>
#include "DHT.h"
#include <Wire.h>
#include <SPI.h>
#include <Adafruit_BMP280.h>

// ========================= PINS =========================
#define AUGER_DIR 13
#define AUGER_PWM 12

#define LA_DIR 25
#define LA_PWM 26

#define TOP_DIR 14  
#define TOP_PWM 27

#define LIMIT_LA  36
#define LIMIT_TOP 39

#define PLATE_STEP 32
#define PLATE_DIR 33

#define servo_DIR 18
#define Servo_PWM 19

#define RL4 1000
#define DHTPIN 4
#define MQ4ANALOGPIN 34
#define DHTTYPE DHT11

// ========================= PWM =========================
const int pwmFreq = 20000;
const int pwmRes  = 8;

const int chAuger = 0;
const int chLA    = 1;
const int chTop   = 2;
const int chServo = 3;

const int fixedPWM_Auger = 200;
const int fixedPWM_LA    = 200;
const int fixedPWM_Top   = 100;
const int fixedPWM_Servo = 150;

// ========================= STEPPER =========================
const int STEPPER_SPEED_US = 200;
const long STEPS_PER_Rev  = 50;

int moveDirLA = 0;
int moveDirTop = 0;
int moveDirPlate = 0;
int moveDirServo = 0;

unsigned long servo_cmd_time = 0;
const unsigned long SERVO_TIMEOUT = 200;

// ========================= micro-ROS =========================
rcl_node_t node;
rclc_executor_t executor;
rcl_allocator_t allocator;
rclc_support_t support;

rcl_subscription_t manipulator_cmd_sub;
rcl_publisher_t debug_pub;

rcl_publisher_t temp_pub;
rcl_publisher_t hum_pub;
rcl_publisher_t methane_pub;
rcl_publisher_t pressure_pub;
rcl_publisher_t altitude_pub;

std_msgs__msg__Int16 manipulator_cmd_msg;
std_msgs__msg__String debug_msg;

std_msgs__msg__Float32 temp_msg;
std_msgs__msg__Float32 hum_msg;
std_msgs__msg__Float32 methane_msg;
std_msgs__msg__Float32 pressure_msg;
std_msgs__msg__Float32 altitude_msg;

#define RCCHECK(fn) if ((fn) != RCL_RET_OK) while (1) {}

// ========================= SENSORS =========================
DHT dht(DHTPIN, DHTTYPE);
Adafruit_BMP280 bmp;

float humidity, temperature, mq4out, rs4, ppm4, ro4;
unsigned status;
// ========================= HELPERS =========================
void motorDrive(int ch, int dirPin, int pwm)
{
  digitalWrite(dirPin, pwm >= 0);
  ledcWrite(ch, abs(pwm));
}

void manipulator_cmd_callback(const void *msgin)
{
  const std_msgs__msg__Int16 *msg = (const std_msgs__msg__Int16 *)msgin;
  int cmd = msg->data;

  motorDrive(chAuger, AUGER_DIR, 0);
  motorDrive(chLA, LA_DIR, 0);
  motorDrive(chTop, TOP_DIR, 0);
  motorDrive(chServo, servo_DIR, 0);
  moveDirPlate = 0;


  if (cmd & (1 << 0)) motorDrive(chAuger, AUGER_DIR,  fixedPWM_Auger);
  if (cmd & (1 << 1)) motorDrive(chAuger, AUGER_DIR, -fixedPWM_Auger);

  if (cmd & (1 << 2)) motorDrive(chLA, LA_DIR,  fixedPWM_LA);
  if (cmd & (1 << 3)) motorDrive(chLA, LA_DIR, -fixedPWM_LA);

  if (cmd & (1 << 4)) motorDrive(chTop, TOP_DIR,  fixedPWM_Top);
  if (cmd & (1 << 5)) motorDrive(chTop, TOP_DIR, -fixedPWM_Top);


  if (cmd & (1 << 6)) { moveDirPlate = +1; digitalWrite(PLATE_DIR, HIGH); }
  if (cmd & (1 << 7)) { moveDirPlate = -1; digitalWrite(PLATE_DIR, LOW); }


 if (cmd & (1 << 8)) {
  motorDrive(chServo, servo_DIR, fixedPWM_Servo);
  servo_cmd_time = millis();
}
if (cmd & (1 << 9)) {
  motorDrive(chServo, servo_DIR, -fixedPWM_Servo);
  servo_cmd_time = millis();
}

 
}



void calibrate()
{
  float sum = 0;
  for(int i = 0; i < 10; i++)
  {
    mq4out = analogRead(MQ4ANALOGPIN);
    sum += mq4out;
    delay(10);
  }

  float avg;
  if(sum != 0)
    avg = sum / 10;
  else
    avg = 6;

  ro4 = RL4 * (4095 - avg) / avg;
}



// ========================= SETUP =========================
void setup()
{
  Serial.begin(115200);
  delay(1500);

  pinMode(AUGER_DIR, OUTPUT);
  pinMode(LA_DIR, OUTPUT);
  pinMode(TOP_DIR, OUTPUT);
  pinMode(servo_DIR, OUTPUT);

  ledcSetup(chAuger, pwmFreq, pwmRes);
  ledcSetup(chLA, pwmFreq, pwmRes);
  ledcSetup(chTop, pwmFreq, pwmRes);
  ledcSetup(chServo, pwmFreq, pwmRes);

  ledcAttachPin(AUGER_PWM, chAuger);
  ledcAttachPin(LA_PWM, chLA);
  ledcAttachPin(TOP_PWM, chTop);
  ledcAttachPin(Servo_PWM, chServo);

  pinMode(PLATE_STEP, OUTPUT);
  pinMode(PLATE_DIR, OUTPUT);


  set_microros_serial_transports(Serial);
  allocator = rcl_get_default_allocator();

  RCCHECK(rclc_support_init(&support, 0, NULL, &allocator));
  RCCHECK(rclc_node_init_default(&node, "manipulator_weather_node", "", &support));

  RCCHECK(rclc_publisher_init_default(&temp_pub, &node,
    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "temperature"));

  RCCHECK(rclc_publisher_init_default(&hum_pub, &node,
    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "humidity"));

  RCCHECK(rclc_publisher_init_default(&methane_pub, &node,
    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "methane_ppm"));


  RCCHECK(rclc_publisher_init_default(&pressure_pub, &node,
    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "pressure"));

  RCCHECK(rclc_publisher_init_default(&altitude_pub, &node,
    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "altitude"));

  RCCHECK(rclc_subscription_init_default(&manipulator_cmd_sub, &node,
    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int16), "manipulator_cmd"));

  RCCHECK(rclc_executor_init(&executor, &support.context, 1, &allocator));
  RCCHECK(rclc_executor_add_subscription(
    &executor, &manipulator_cmd_sub,
    &manipulator_cmd_msg, &manipulator_cmd_callback, ON_NEW_DATA));

     calibrate();
     
  dht.begin();
  
  bmp.begin(0x76);
  
  
  status = bmp.begin(0x76);
  if (!status)
    Serial.println("BMP280 not initialized");

  dht.begin();

  bmp.setSampling(Adafruit_BMP280::MODE_NORMAL,     
                  Adafruit_BMP280::SAMPLING_X2,     
                  Adafruit_BMP280::SAMPLING_X16,    
                  Adafruit_BMP280::FILTER_X16,      
                  Adafruit_BMP280::STANDBY_MS_500);   
}

// ========================= LOOP =========================
void loop()
{
  rclc_executor_spin_some(&executor, RCL_MS_TO_NS(10));

  if (moveDirPlate != 0)
  {
    for (int i = 0; i < STEPS_PER_Rev; i++)
    {
      if (moveDirPlate == 0) break;
      digitalWrite(PLATE_STEP, HIGH);
      delayMicroseconds(STEPPER_SPEED_US);
      digitalWrite(PLATE_STEP, LOW);
      delayMicroseconds(STEPPER_SPEED_US);
    }
  }

  if (millis() - servo_cmd_time > SERVO_TIMEOUT)
  {
  motorDrive(chServo, servo_DIR, 0);
  }



  // ===== MQ-4 Methane Sensor =====
  mq4out = analogRead(MQ4ANALOGPIN);   // raw ADC value (0â€“4095 on ESP32)


 
  
  
  if(mq4out != 0)
  {
    rs4 = RL4 * (4095 - mq4out) / mq4out;
    ppm4 = 1.8 + pow(rs4 / ro4, -2.00) / 100;
  }
  else
  {
    ppm4 = 1.8;
  }
  
  
  float pressure = bmp.readPressure() / 100.0F;
  float altitude = bmp.readAltitude(1015);
  
  hum_msg.data = dht.readHumidity();
  temp_msg.data = dht.readTemperature();
  methane_msg.data = ppm4;
  pressure_msg.data = pressure;
  altitude_msg.data = altitude;

  rcl_publish(&hum_pub, &hum_msg, NULL);
  rcl_publish(&temp_pub, &temp_msg, NULL);
  rcl_publish(&methane_pub, &methane_msg, NULL);
  rcl_publish(&pressure_pub, &pressure_msg, NULL);
  rcl_publish(&altitude_pub, &altitude_msg, NULL);


  delay(10);
}
